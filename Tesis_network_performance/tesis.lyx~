#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 1cm
\rightmargin 4cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part*

\lang spanish-mexico
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset

Tecnologías de comunicación para aplicaciones del Internet de las Cosas.
\end_layout

\begin_layout Section

\lang spanish-mexico
Introducción 
\end_layout

\begin_layout Standard

\lang spanish-mexico
El termino Industria 4.0 (I40) hace referencia a la cuarta evolución tecnológica
 por la que la industria esta pasando actualmente.
 Esta pretende, a traves de tecnologías como sistemas ciberfísicos (CPS
 - cyber physical systems)y el Internet de las cosas, crear una producción
 inteligente, descentralizada y autónoma con sistemas trabajando en tiempo
 real, con la finalidad de brindar al cliente un servicio lo mas personalizado
 posible.
 Los Sistemas Embebidos proporcionan la base para la creación de los CPS,
 los cuales a su vez se relacionan para crear un Internet de las Cosas,
 quien se combina con el Internet de los Servicios para hacer posible la
 I40.
 46
\end_layout

\begin_layout Standard

\lang spanish-mexico
En este contexto, la recopilación y evaluación integral de datos de diferentes
 fuentes (equipos y sistemas de producción, así como sistemas de gestión)
 se convertirán en estándar para soportar la toma de decisiones en tiempo
 real 53.
 Ademas, con el aumento de la conectividad y el uso de protocolos de comunicacio
nes estándar que vienen con la I40, la necesidad de proteger los sistemas
 industriales críticos y las líneas de fabricación de las amenazas, aumenta
 dramáticamente 53.
 Por lo tanto, definir los estándares de comunicación mas eficientes, se
 vuelve algo fundamental al momento de querer construir un sistema CPS,
 ya que el núcleo computacional de un CPS es un sistema de tiempo-real estricto,
 es decir, que es absolutamente necesesario que produzca respuestas correctas
 dentro de un intervalo de tiempo definido, si el tiempo de respuesta excede
 ese límite, se produce un funcionamiento erróneo en el sistema.
 47
\end_layout

\begin_layout Standard

\lang spanish-mexico
La red de comunicaciones del CPS debe también debe ofrecer prestaciones
 de tiempo-real estricto.
 Tecnologías de red tales como Ethernet, WiFi, Bluetooth o ZigBee, utilizan
 protocolos con la política del mejor esfuerzo, ya que si bien ofrecen un
 muy buen rendimiento, no hay garantía del tiempo de entrega de los mensajes.
 Por otra parte, recientemente se han propuesto protocolos con prestaciones
 de tiempo-real estricto, tales como Real-Time Ethernet, WirelessHART o
 ISA 100, que en teoría son mas adecuados para ser utilizados en los CPS
 y en aplicaciones de la I40.
 Sin embargo, no existen estudios comparativos de su desempeño ni se ha
 experimentado que tan superiores son con respecto a los protocolos de redes
 de propósito general.
 Por otra parte, es importante conocer qué soporte existe para su uso en
 SCP, su facilidad de instalación, el soporte de bibliotecas para el desarrollo
 de aplicaciones, entre otros parámetros.
 48
\end_layout

\begin_layout Standard

\lang spanish-mexico
El desarrollo de este trabajo busca identificar cual es el protocolo de
 redes de computadoras más conveniente para el desarrollo de aplicaciones
 en el contexto de la I40, así como presentar resultado de un estudio comparativ
o de los protocolos de red más importantes de la actualidad.
\end_layout

\begin_layout Subsection

\lang spanish-mexico
Objetivos generales.
\end_layout

\begin_layout Standard

\lang spanish-mexico
Evaluar los protocolos de redes de computadoras más importantes, para poder
 determinar cual el más conveniente para ser utilizado en el contexto de
 alguna aplicación específica de la Industria 4.0.
\end_layout

\begin_layout Subsection

\lang spanish-mexico
Objetivos específicos.
 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Definir cuales son las características con las que debe cumplir un protocolo
 para que pueda ser utilizado en aplicaciones I04.
 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Definir experimentos para determinar si los protocolos cumplen con las caracterí
sticas definidas.
 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Determinar y estudiar los protocolos a evaluar con los experimentos predefinidos.
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Evaluar los protocolos elegidos para determinar sus caracteristicas y comprobar
 su funcionamiento dentro de a I40.
 
\end_layout

\begin_layout Section

\lang spanish-mexico
Trabajos relacionados
\end_layout

\begin_layout Standard

\lang spanish-mexico
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="10col%">
<column alignment="left" valignment="top" width="12col%">
<column alignment="left" valignment="top" width="17col%">
<column alignment="left" valignment="top" width="16col%">
<column alignment="left" valignment="top" width="17col%">
<column alignment="left" valignment="top" width="16col%">
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none" width="10col%">
\begin_inset Text

\begin_layout Plain Layout
Trabajo
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Protocolos estudiados
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objetivos
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Metodos
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Escenarios
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Datos relevantes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none" width="12col%">
\begin_inset Text

\begin_layout Plain Layout

\lang spanish-mexico
Integración de ZigBee/6loWPAN en una red de sensores inalabrica.
 [49]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ZigBee y 6LoWPAN.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Empresas como SAYME ofrecen productos en el ambito de las redes de sensores
 inalambricas basados en el estandar IEEE 802.15.4.
 Se pretende estudiar y desarrollar un sistema compatible con los actuales
 que implemente otras tecnologias estandarizadas como: ZigBee y 6LoWPAN.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se analiza el funcionamiento de los protocolos, exponiendo ventajas y desventaja
s qeu con lleva al realizar una integración con hardware que funcione con
 el estandar IEEE 802.15.4 en el ambito de sensores.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se proponen cambios al hardware existente para llevar a cabo una integración
 con las tecnologias, tambien se propuso el diseño de una app de prueba.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Muestran especial interes en la dificultad que tiene el estandar 6LoWPAN
 para implementarlo en algun producto.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang spanish-mexico
A Comparison of WirelessHART and ZigBee for Industrial Applications.
 [50]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WirelessHART y ZigBee.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se presentan las razones del por que ZigBee no se considera adecuada para
 usarla en la mayoria de las aplicaciones indutriales, cosa que motivó el
 desarrollo de un nuevo estandar de comunicación que se ajusta a las necesidades
 de la industria: WirelessHART.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se hace una exposición sobre las caracteristicas más distinguidas de ambos
 protocolos: 
\end_layout

\begin_layout Plain Layout
- Descripción general.
\end_layout

\begin_layout Plain Layout
- Funcionamientos Básicos.
 
\end_layout

\begin_layout Plain Layout
- Seguridad.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Los protocolos se comparan en areas de interés para aplicaciones industriales.
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
La comparación muestra que WirelessHART aborda muchas de las debilidades
 popr las que ha sido criticado ZigBee y por lo tanto tiene potencial de
 éxito en las aplicaciones industriales.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang spanish-mexico
A Survey of ZigBee Wireless Sensor Network Technology: Topology, Applications
 and Challenges.
 [51]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ZigBee
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dar una vision general de ZigBee como una tecnología basada en una red de
 sensores inalambrica, incluyendo su topología, aplicaciones y retos.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Durante la descripción de la tecnología, caracteristicas de Wifi, Bluetooth
 y ZigBee se resumen y comparan en una tabla, tomando en cuenta: Aplicaciones,
 Bandas de frecuencia, Vida de la bateria, Nodos por red, ancho de banda
 y rango.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ZigBee tiene una amplia variedad de areas de aplicacion, tales como automatizaci
ón del hogar y de comercios, infraestructura para el ahorro inteligente
 de energia, cuidado de la salud, monitoreo y control en procesos industriales,
 control remoto para dispositivos electronicos, entre otros.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comparado con Wifi y Bluetooth, la pila del protocolo de ZigBee tiene un
 peso mas ligero, tiene un mayor rendimiento de transmisión, ademas, si
 bien se informa que los dispositivos wifi tienen entre 12 y 8 horas de
 duración de batería y los dispositivos bluetooth una duracion de batería
 de unos pocos dias, muchos dispositivos ZigBee pueden tener una duración
 de batería hasta por 5 años.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang spanish-mexico
Bluetooth and Wi-Fi wireless protocols: A survey and a comparison.
 [52]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Wi-Fi y Bluetooth
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dar una vista general de los estandares de comunicación Wi-Fi y Bluetooth.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Compara las principales caracteristicas y funcionamientos de ambos protocolos
 en terminos de varias metricas, incluyendo capacidad, topología de red,
 seguridad, calidad del servicio de soporte y consumo de energía.
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
La comparación de estos protocolos se hizo tomando en cuenta que ambas tenología
s han sido desarrolladas para aplicaciones de corto alcance, tales como:
 comunicación en telefonos moviles, computadoras portatiles, vehiculos con
 asistente de viaje, etc.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Las areas de investigación de los protocolos incluyen una eficiente solución
 para el problema de la estación oculta, 
\series bold
soporte a las transmisiones de tiempo real,
\series default
 incrementar la seguridad en la transmisión de datos, entre otras.
 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section

\lang spanish-mexico
Protocolos de redes de computadoras para Internet de las Cosas
\end_layout

\begin_layout Subsection
Wi-Fi.
 
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Descripción.
 
\end_layout

\begin_layout Standard

\lang spanish-mexico
Wi-Fi o WLAN (redes de área local inalámbricas) es una red inalámbrica basada
 en una serie de especificaciones del Instituto de Ingenieros Eléctricos
 y Electrónicos (IEEE) denominada 802.11.
 Wi Fi utiliza radiofrecuencia sin licencia, principalmente en la banda
 de 2,4 GHz.
 Permite que una persona con una computadora o dispositivo movil con capacidad
 inalámbrica se conecte a Internet a través de un punto de acceso inalámbrico.
 La región geográfica cubierta por uno o varios puntos de acceso se denomina
 zona activa.
 El Wi-Fi estaba destinado a ser utilizado para dispositivos móviles y redes
 de área local, pero ahora se utiliza a menudo para el acceso a Internet
 en exteriores.
 1
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Historia.
 
\end_layout

\begin_layout Standard

\lang spanish-mexico
En el año de 1999, varias empresas (3Com, Airones, Intersil, Lucent Technologies
, Nokia y Symbol Technologies) se unieron para conseguir formar una asociación
 sin fines de lucro a fin de mejorar la experiencia de usuario sin importar
 la marca de los dispositivos, utilizando una nueva tecnología de redes
 inalámbricas, por el año 2000 se le definió el término “Wi-Fi” para su
 trabajo técnico y anunció su nombre oficial como Wireless Ethernet Compatibilit
y Alliance o WECA, pero a dia de hoy es llamada Wi-Fi Alliance.
 2 A día de hoy la Wi-Fi Alliance está conformada por cientos de empresas
 en muchos países y poseen una visión común: “Conectar a todos y a todo”
 , por lo que se dedican a impulsar nuevas tecnologías y aplicaciones para
 el uso del Wi-Fi.
 3
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Organismo que lo desarrolla o regula.
\end_layout

\begin_layout Standard

\lang spanish-mexico
Wi-Fi Alliance, la cual es una organización que cumple con los estándares
 802.11 establecidos por la IEEE.
 4
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Principales características.
\end_layout

\begin_layout Standard

\lang spanish-mexico
El estándar 802.11n de la IEEE es casi sinónimo de Wi-Fi , mejora respecto
 a sus versiones anteriores, en la actualidad, la Wi-Fi Alliance decidió
 hacer lo mismo que bluetooth esté estándar se llama 802.15.1 oficialmente
 pero es mejor conocido como bluetooth, entonces sus nuevas versiones son
 bluetooth 5.0, ahora la Wi-Fi Alliance utilizara Wi-Fi 6 para 802.11ax, Wi-Fi
 5 para 802.11ac y Wi-Fi 4 para el 802.11n.
 5 “La norma 802.11 sigue el mismo modelo o arquitectura que toda la familia
 802, es decir: capa física y capa enlace”, si se mira a mas detalle la
 subcapa inferior, PMD (Physical Media Dependent), que corresponde al conjunto
 de especificaciones de cada uno de los sistemas de transmisión a nivel
 físico, el estándar define cuatro: Infrarrojos, FHSS, DSSS y OFDM.
 La subcapa superior, PLCP (Physical Layer Convergence Procedure), se encarga
 de adaptar las diversas especificaciones de la subcapa PMD a la subcapa
 MAC, inmediatamente superior.
 6 La velocidad máxima teórica del estándar 802.11ax es de 2.4 Gbps manteniendo
 una frecuencia entre 2.4 y 5 GHz, alcance <100 metros.
 Estantandar en IoT: Wi-Fi Halow es una designación para productos que incorpora
n la tecnología IEEE 802.11.ah.
 Mejora el Wi-Fi al trabajar en un espectro por debajo de 1GHz con más alcance
 y conectividad de bajo consumo energético ideal para dispositivos IoT.
 7
\end_layout

\begin_layout Standard

\lang spanish-mexico
IMAGEN Modelo OSI y la Familia IEEE 802.11 
\end_layout

\begin_layout Standard

\lang spanish-mexico
IMAGEN Resumen del protocolo Wi-Fi IEEE 802.11
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Topologías.
 
\end_layout

\begin_layout Standard

\lang spanish-mexico
Toda red inalámbrica compleja está compuesta por la combinación de una o
 más tipos de conexiones: 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Punto a punto 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Punto a multipunto 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Multipunto a multipunto.
\end_layout

\begin_layout Standard

\lang spanish-mexico
Las redes inalámbricas WiFi contempla tres topologías o configuraciones
 distintas:
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Modo infraestructura o BSS: “Contrario al modo ad hoc donde no hay un elemento
 central, en el modo de infraestructura hay un elemento de “coordinación”:
 un punto de acceso o estación base.” 8 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Modo ad hoc o IBSS: “También conocido como punto a punto, es un método para
 que los clientes inalámbricos puedan establecer una comunicación directa
 entre sí.” 8 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Modo ESS: “Se trata de un conjunto de BSS conectados mediante un sistema
 de distribución.
 Los puntos de acceso se comunican entre sí para permitir que las estaciones
 puedan pasar de un BSS a otro sin perder la comunicación, servicio denominado
 roaming.” 9
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Bibliotecas para el desarrollo de aplicaciones.
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Biblioteca Wifi para arduino: Para que una placa arduino se conecte a internet
 tiene que hacer uso de un elemento llamado "Arduino WiFi Shield" y para
 manipularlo se hace uso de la WiFi Library("#include <WiFi.h>").
 10
\end_layout

\begin_layout Itemize

\lang spanish-mexico
WifiManager: es una clase que provee la principal API para manejar todos
 los aspectos relacionados la conectividad WiFi con java.
 11 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Python-wifi: Es un módulo de python que proporciona acceso de lectura y
 escritura a las capacidades de una tarjeta de red inalámbrica usando las
 extensiones inalámbricas de linux, para implementarlo utilice “pip instalar
 python-wifi”.
 12
\end_layout

\begin_layout Itemize

\lang spanish-mexico
WifiUtils: es una biblioteca que proporciona un conjunto de métodos convenientes
 para administrar el estado de WiFi, el escaneo de WiFi y la conexión de
 WiFi a puntos de acceso.
 13
\end_layout

\begin_layout Subsection

\lang spanish-mexico
Bluetooth 
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Descripción.
\end_layout

\begin_layout Standard

\lang spanish-mexico
“Bluetooth es una especificación industrial para redes inalámbricas de área
 personal que posibilita la transmisión de voz y datos entre diferentes
 dispositivos mediante un enlace por radiofrecuencia.” 14
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
2.1 Historia.
\end_layout

\begin_layout Standard

\lang spanish-mexico
Bluetooth fue nombrado en homenaje al rey danés Harald Blatand (Harold Bluetooth
 en inglés) conocido por ser un gran comunicador y por haber unificado los
 pueblos de Dinamarca, Noruega y Suiza.
 Bluetooth fue creado con la intención de comunicar dos tecnologías diferentes,
 los ordenadores y los teléfonos móviles.
 A comienzos del año 2000 el Bluetooth SIG lanzó el logo como la fusión
 de dos letras del alfabeto rúnico,hagall y berkana que representan la H
 y la B, las iniciales del rey, lo que da como resultado su característico
 logo.
 14 En el año de 1994 Ericsson tenía la necesidad de una conexión entre
 dispositivos, con una interfaz vía radio y de bajos recursos, se llegó
 a un sistema basado en la comunicación por radio de corto alcance, llamado
 Mclink, en el año 1998 nació el Bluetooth Special Interest Group(SIG),
 promovido por las empresas Ericsson, Nokia, Toshiba, IBM e Intel, al agrupar
 las empresas líderes de las comunicaciones se llegó al éxito del Bluetooth.
 14
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Organismo que lo desarrolla o regula.
\end_layout

\begin_layout Standard

\lang spanish-mexico
Bluetooth Special Interest Group (SIG) es quien regula Bluetooth, en la
 actualidad SIG está conformado por más de 36000 empresas que buscan unificar,
 armonizar e impulsar la innovación en el vasto rango de dispositivos conectados
 que nos rodean.
 15
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Principales características.
\end_layout

\begin_layout Standard

\lang spanish-mexico
La siguiente figura muestra un diagrama de la pila de protocolos de Bluetooth.
 La pila o stack se compone de protocolos específicos de Bluetooth como
 tecnología inalámbrica, así como del protocolo de búsqueda de servicios
 SDP, u otros protocolos adoptados como el protocolo de intercambio de objetos
 OBEX.
 16
\end_layout

\begin_layout Standard

\lang spanish-mexico
IMAGEN
\end_layout

\begin_layout Itemize

\lang spanish-mexico
El protocolo de gestión del enlace LMP se responsabiliza del establecimiento
 y configuración del enlace entre los dispositivos.
\end_layout

\begin_layout Itemize

\lang spanish-mexico
La HCI proporciona una interfaz con el módulo radio, el controlador de la
 banda base y el gestor de enlace.
 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
El protocolo de control del enlace lógico y adaptación L2CAP abstrae a las
 capas superiores de los detalles de los protocolos de capas inferiores.
\end_layout

\begin_layout Itemize

\lang spanish-mexico
SDP proporciona a las aplicaciones un medio para realizar búsquedas de servicios
 y de sus características.
 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
RFCOMM ofrece una emulación de un puerto serie sobre L2CAP proporcionando
 el mecanismo de transporte a servicios de capas más altas, permitiendo
 realizar múltiples conexiones con un dispositivo al mismo tiempo.
 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
La especificación del protocolo de control telefónico, TCS binary, define
 la señalización de control de llamadas para el establecimiento de llamadas
 de voz y datos entre dispositivos Bluetooth.
 16
\end_layout

\begin_layout Standard

\lang spanish-mexico
IMAGEN Comparativa del modelo osi y los protocolos de Bluetooth.
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Topologías.
 
\end_layout

\begin_layout Standard

\lang spanish-mexico
La topología de las redes Bluetooth puede ser punto-a-punto o punto-a multipunto.
 Los dispositivos, se comunican en redes denominadas piconets.
 Estas redes tienen posibilidad de crecer hasta tener 8 conexiones punto
 a punto.
 Además, se puede extender la red mediante la formación de scatternets,
 el cual es la red producida cuando dos dispositivos pertenecientes a dos
 piconets diferentes, se conectan.
 En una piconet, un dispositivo debe actuar como master, enviando la información
 del reloj (para sincronizarse) y la información de los saltos de frecuencia.
 El resto de los dispositivos actúan como slaves (esclavos).
 16
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Bibliotecas para el desarrollo de aplicaciones
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Bluez: Se trata de una biblioteca que se utiliza para emitir comandos y
 escuchar eventos de los controladores bluetooth para linux.
 17 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Node-bluetooth: Es una biblioteca que permite la comunicación de puerto
 serial bluetooth para Node.js, funciona en Linux y se necesita tener libbluetoot
h-dev (En Ubuntu/Debian: "$ sudo apt-get install libbluetooth-dev") para
 instalar node-bluetooth use la siguiente instrucción: "$ npm install node-bluet
ooth --save".
 18 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
BluetoothManager: Es una biblioteca que facilita el uso de bluetooth en
 las aplicaciones de windows 10.
 19 
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Android.bluetooth: La plataforma de android incluye compatibilidad con la
 pila de red Bluetooth, la cual permite que un dispositivo intercambie datos
 de manera inalámbrica con otros dispositivos Bluetooth.
 20
\end_layout

\begin_layout Subsection

\lang spanish-mexico
ZigBee 
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Descripción.
\end_layout

\begin_layout Standard

\lang spanish-mexico
Zigbee es un estándar de comunicaciones inalámbricas diseñado por la Zigbee
 Alliance.
 Es un conjunto estandarizado de soluciones que pueden ser implementadas
 por cualquier fabricante, está basado en el estándar IEEE 802.15.4 de redes
 inalámbricas de área personal (Wireless Personal Area Network, WPAN) y
 tiene como objetivo las aplicaciones que requieren comunicaciones seguras
 con baja tasa de envío de datos y maximización de la vida útil de sus baterías.
 21
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Historia.
\end_layout

\begin_layout Standard

\lang spanish-mexico
La idea de las redes de familia Zigbee fue concebida en el año 1998 donde
 quedó claro que Wi-Fi y Bluetooth no cubrirán todos los contextos, bajo
 la necesidad de redes descentralizadas.
 En el 2003 se aprobó el estándar de la IEEE 802.15.4 , por lo cual Zigbee
 Alliance alcanzó sus objetivos, y actualmente colabora para crear y desarrollar
 estándares abiertos para los dispositivos que utilizamos dia a dia.
 También aporta soluciones abiertas de internet de las cosas, principalmente
 en la domótica.
 22 3.2 Organismo que lo desarrolla o regula: Zigbee fue desarrollado por
 Zigbee Alliance y actualmente es quien lo regula, fue establecida en el
 2002.
 23
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Principales características.
\end_layout

\begin_layout Standard

\lang spanish-mexico
Zigbee es un sistema ideal para redes domóticas, está diseñado para reemplazar
 la proliferación de sensores individuales, cubre las necesidades del mercado
 a un bajo costo, bajo consumo y de manera muy segura.
 
\end_layout

\begin_layout Standard

\lang spanish-mexico
IMAGEN Pila de protocolos IEEE 802.5.4
\end_layout

\begin_layout Standard

\lang spanish-mexico
Está basado en el estándar IEEE 802.15.4 de redes inalámbricas, define el
 nivel físico y el control de acceso al medio de redes inalámbricas de área
 personal con tasas bajas de transmisión de datos.
 Opera en la banda libre de ISM 2.4 GHz para conexiones inalámbricas con
 un alojamiento de 16 bits a 64 bits de dirección extendida y 128-bit AES
 de cifrado por lo cual provee conexiones seguras entre dispositivos, además,
 su alcance es de 10 m a 75m.
 24
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Topologías.
 
\end_layout

\begin_layout Standard

\lang spanish-mexico
Zigbee permite tres topologías de red: Topología de estrella: El coordinador
 se sitúa en el centro.
 Topología en árbol: El coordinador será la raíz del árbol.
 Topología de malla: Al menos uno de los nodos tendrá más de dos conexiones.
 Hasta 65.000 nodos en una red (Las limitaciones físicas no permiten tantos
 nodos, por ej.
 ancho de banda o memoria.) 25
\end_layout

\begin_layout Standard

\lang spanish-mexico
IMAGEN
\end_layout

\begin_layout Standard

\lang spanish-mexico
La topología más interesante es la de malla, la cual permite que si, en
 un momento dado, un nodo del camino falla y se cae, pueda seguir la comunicació
n entre todos los demás nodos debido a que se rehacen todos los caminos.
 25
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Bibliotecas para el desarrollo de aplicaciones
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Una biblioteca de .Net Multiplataforma para la comunicación entre dispositivos
 Zigbee es: ZigBeeNet, debido a que Zigbee es solo una especificación, necesita
 una pila de un fabricante que la implemente.
 ZigBeeNet se desarrolla con una separación estricta de Zigbee Cluster Library
 (ZCL) y las distintas pilas de fabricantes.
 Por eso, es posible utilizar hardware diferente para su solución Zigbee.
 26
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Para aplicaciones con C#: XBee C# Library es una API desarrollada en C #
 que le permite interactuar con los módulos de radiofrecuencia (RF), ofrecida
 por Digi International, empresa que ofrece soluciones para IoT.
 Posee dos módulos, XBeeLibrary.Core, contiene el código común para cualquier
 plataforma y XBeeLibrary.Xamarin, la cual contiene las API´s necesarias
 para desarrollar aplicaciones móviles multiplataforma en Xamarin para comunicar
se con dispositivos Xbee sobre Bluetooth de baja energía.
 27
\end_layout

\begin_layout Itemize

\lang spanish-mexico
XBee Java Library: APi desarrollada en java que permite interactuar con
 los módulos de radiofrecuencia XBee de Digi International, también existe
 una biblioteca llamada XBee Android ofrecida igualmente por Digi International
 basada en XBee Java library, la cual hace énfasis en el desarrollo de aplicacio
nes móviles para android, de igual manera ofrece soporte para diferentes
 interfaces de comunicación con dispositivos XBee por Bluetooh, usb o por
 el puerto serial.
 28
\end_layout

\begin_layout Itemize

\lang spanish-mexico
XBee Python: Esta es una biblioteca para python, la cual utiliza el módulo
 PySerial para comunicarse con los módulos de radio, también utiliza el
 módulo SRP para una autenticación entre dispositivos a través de Bluetooth
 de baja energía, ambos módulos se descargan de manera autónoma al instalar
 la biblioteca mediante: “pip install digi-xbee”.
 29
\end_layout

\begin_layout Subsection

\lang spanish-mexico
LoRa 
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Descripción.
 
\end_layout

\begin_layout Standard

\lang spanish-mexico
LoRa es una tecnología inalámbrica (al igual que WiFi, Bluetooth o Zigbee)
 que emplea un tipo de modulación en radiofrecuencia patentado por Semtech,
 utiliza la tecnología de modulación se denomina Chirp Spread Spectrum (o
 CSS) y se emplea en comunicaciones militares y espaciales desde hace décadas.
 30
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Historia.
 
\end_layout

\begin_layout Standard

\lang spanish-mexico
LoRa (significa Long Range) es una tecnica de modulacion de red de área
 amplia de baja potencia, se basa en técnicas de modulación de espectro
 y fue desarrollada por Semtech, proveedor de semiconductores analogicos,
 de señal mixta y algoritmos avanzados para consumidores de informática
 empresarial.
 Hoy en dia, LoRa es administrado por LoRa Alliance quien es una organización
 creada en el 2015 para admitir el protocolo LoRaWAN y garantizar la interoperab
ilidad de los productos que utilizaban esta tecnología, actualmente posee
 más de 500 miembros, entre ellos IBM, Cisco y Semtech.
 30
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Organismo que lo desarrolla o regula.
\end_layout

\begin_layout Standard

\lang spanish-mexico
En la actualidad LoRa está administrada por la LoRa Alliance, quien certifica
 a todo fabricante de hardware que desee trabajar con esta tecnología.
 LoRa Alliance es una organización sin fines de lucro que se a convertido
 en una de las más grandes alianzas del sector tecnológico, comprometida
 a permitir el despliegue a gran escala con un bajo nivel energético en
 redes de área amplia (LPWAN) IO a través del desarrollo y la promoción
 de LoRaWAN.
 31
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Principales características.
\end_layout

\begin_layout Standard

\lang spanish-mexico
LoRaWAN es un protocolo de red que usa la tecnología LoRa, para redes de
 baja potencia y área amplia, LPWAN (Low Power Wide Area Network) empleado
 para comunicar y administrar dispositivos LoRa.
 El protocolo LoRaWAN se compone de gateways y nodos: gateways (antenas):
 son los encargados de recibir y enviar información a los nodos.
 nodos (dispositivos): son los dispositivos finales que envían y reciben
 información hacia el gateway.
 32
\end_layout

\begin_layout Standard

\lang spanish-mexico
LoRa posee una alta tolerancia a las interferencias, alta sensibilidad para
 recibir datos (-168dB), es basada modulación “chirp” y su bajo consumo
 energético rinde hasta 10 años con una sola batería.
 Alcance de 10 a 20 km Baja transferencia de datos (hasta 255 bytes) Conexión
 punto a punto Frecuencias de trabajo: 868 Mhz en Europa, 915 Mhz en América,
 y 433 Mhz en Asia.
 LoRa es una tecnología ideal para conexiones a grandes distancias y para
 redes de IoT en las que se necesitan sensores que no dispongan de corriente
 eléctrica de red, teniendo grandes aplicaciones: Para Smart Cities (ciudades
 inteligentes) Lugares con poca cobertura (cómo explotaciones agrícolas
 o ganaderas en el campo) Para construir redes privadas de sensores y/o
 actuadores.
 32 
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Topologías.
 
\end_layout

\begin_layout Standard

\lang spanish-mexico
Permite la interconexión entre objetos inteligentes sin la necesidad de
 instalaciones locales complejas, y además otorga amplia libertad de uso
 al usuario final, al desarrollador y a las empresas que quieran instalar
 su propia red para Internet de las Cosas (IoT).
 32 
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Bibliotecas para el desarrollo de aplicaciones.
\end_layout

\begin_layout Itemize

\lang spanish-mexico
Arduino-LoRa: Una biblioteca Arduino para enviar y recibir datos usando
 radios LoRa.
 Admite placas / shields basados en Semtech SX1276 /77/78/79.
 33
\end_layout

\begin_layout Itemize

\lang spanish-mexico
pyLoRa: es una adaptación y una versión mejorada del trabajo mayeranalytic
 original (mayeranalytics / pySX127x) pyLoRa se puede usar para comunicarse
 con Arduino a través de la biblioteca RADIOHEAD, la cual es una biblioteca
 orientada a objetos para enviar y recibir mensajes empaquetados a través
 de una variedad de radios de datos comunes y otros transportes en una variedad
 de microprocesadores integrados.
 34
\end_layout

\begin_layout Itemize

\lang spanish-mexico
ESP32_LoRaWAN: Proporciona una implementación de LoRaWAN Clase A y Clase
 C bastante completa, este es un puerto de la biblioteca LoRaWAN del nodo
 LoRaMac de Semtech para el ESP32 y solo se puede utilizar para productos
 Heltec ESP32 LoRa (Se requiere licencia para su uso).
 35
\end_layout

\begin_layout Subsection

\lang spanish-mexico
LoWPAN 
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Descripción.
 
\end_layout

\begin_layout Standard

\lang spanish-mexico
Un LoWPAN es una red de comunicación simple de bajo costo que permite conectivid
ad inalámbrica en aplicaciones con energía limitada y relajada.
 Un LoWPAN generalmente incluye dispositivos que trabajan juntos para conectar
 el entorno físico con el mundo real, por ejemplo, sensores inalámbricos.
 6LoWPAN es un estándar que posibilita el uso de IPv6 sobre redes basadas
 en el estándar IEEE 802.15.4.
 36
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Historia,
\end_layout

\begin_layout Standard

\lang spanish-mexico
El grupo de trabajo IETF 6LoWPAN se inició oficialmente en 2005, aunque
 la historia de la propiedad intelectual integrada se remonta más atrás.
 Las primeras especificaciones de 6LoWPAN se publicaron en 2007, primero
 con un RFC informativo [RFC4919] que especifica los requisitos y objetivos
 subyacentes de la estandarización inicial, y luego con un RFC de seguimiento
 estándar [RFC4944] que especifica el formato y la funcionalidad de 6LoWPAN.
 37 En 2008 se formó un nuevo grupo de trabajo IETF, este especifica los
 requisitos y las soluciones de enrutamiento para redes inalámbricas, poco
 fiables y de bajo consumo.
 En 2008, ISA comenzó a estandarizar un sistema de automatización industrial
 inalámbrico llamado SP100.11a (también conocido como ISA100), que se basa
 en 6LoWPAN.
 Aún por el 2008 la IP500 Alliance, comenzó a desarrollar una recomendación
 para 6LowPAN sobre IEEE 802.15.4 En 2009 Zigbee Alliance anunció que comenzará
 a integrar estándares IETF como 6LowPAN en sus especificaciones futuras.
 37
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Organismo que lo desarrolla o regula.
\end_layout

\begin_layout Standard

\lang spanish-mexico
El grupo de trabajo IETF 6LoWPAN.
 El IETF( Internet Engineering Task Force) es una gran comunidad internacional
 abierta de diseñadores, operadores, comercializadores e investigadores
 de redes que se ocupan de la evolución de Internet y su buen funcionamiento.
 38
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Principales características.
\end_layout

\begin_layout Standard

\lang spanish-mexico
6LowPAN ha sido diseñada para enviar paquetes IPv6 sobre redes IEEE 802.15.4,
 para luego implementar protocolos superiores como TCP, UDP, HTTP, COAP,
 MQTT y websockets.
 Como se puede apreciar en la imagen de abajo, 6LowPAN se encuentra entre
 las capas de enlace y red, pudiendo llegar incluso a la capa de transporte
 compitiendo con otros protocolos que a su vez también incorporan la especificac
ión 6LowPAN.
 39
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Topologías.
 
\end_layout

\begin_layout Standard

\lang spanish-mexico
6LowPAN es una red de topología en malla robusta, escalable y auto-regenerativa,
 también puede funcionar en topología de tipo estrella, y en general las
 mismas que el estándar 802.15.4.
 
\end_layout

\begin_layout Subsection

\lang spanish-mexico
Wireless HART.
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Descripción.
\end_layout

\begin_layout Standard

\lang spanish-mexico
WirelessHART es un estándar (62591) global aprobado por la IEC que especifica
 una tecnología de malla interoperable auto-organizada en el cual los dispositiv
os de la red inalámbrica mitigan obstáculos en el ambiente del proceso,
 posee excelentes habilidades para el control y monitoreo, con una gran
 confiabilidad.
 40
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Historia.
\end_layout

\begin_layout Standard

\lang spanish-mexico
El estándar comenzó en el 2004 y fue desarrollado por 37 empresas de la
 fundación de comunicaciones HART (HCF), entre las empresas pertenecientes
 se encuentran: Emerson, Pepperl y Siemens.
 WirelessHART fue aprobada por la junta directiva de la fundación en el
 año 2007, posteriormente en el 2009 WirelessHART fue aprobado por la Comisión
 Electrotécnica Internacional (IEC).
 41
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Organismo que lo desarrolla o regula.
 
\end_layout

\begin_layout Standard

\lang spanish-mexico
FieldComm Group es propietario de las especificaciones HART y proporciona
 servicios de registro de productos, capacitación y desarrollo de especificacion
es asociados con la tecnología.
 42 6.3 Principales características: WirelessHART es un protocolo basado
 en la especificación IEEE 802.15.4 en las capas bajas del modelo OSI, al
 igual que Zigbee o ISA 100, cubriendo la especificación de las capas superiores.
 La característica principal de este protocolo es su bajo consumo, lo que
 le permite ser usado en dispositivos alimentados por baterías sin agotarse
 en un corto periodo de tiempo.
 43
\end_layout

\begin_layout Standard

\lang spanish-mexico
(IMAGEN) relación entre WirelessHART y el modelo OSI.
 43
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Topologías.
 
\end_layout

\begin_layout Standard

\lang spanish-mexico
WirelessHART utiliza una red mallada plana en la que todas las estaciones
 de radio (dispositivos de campo) forman una red.
 Todas las estaciones actúan simultáneamente como fuente de señal y repetidor.
 44 El transmisor original envía un mensaje a su vecino más próximo, que
 a su vez transmite el mensaje hasta que llega a la estación base y al receptor.
 Además, se configuran rutas alternativas en la fase de inicialización.
 Si el mensaje no se puede transmitir en una ruta concreta por causa de
 un obstáculo o un receptor defectuoso, el mensaje se transmite automáticamente
 a una ruta alternativa.
 Además de ampliar el rango de la red, la red mallada plana proporciona
 rutas de comunicación redundantes que aumentan la fiabilidad de la transmisión.
 44
\end_layout

\begin_layout Standard

\lang spanish-mexico
(IMAGEN) Topología de red mallada WirelessHART 44
\end_layout

\begin_layout Subsubsection

\lang spanish-mexico
Bibliotecas para el desarrollo de aplicaciones.
\end_layout

\begin_layout Itemize

\lang spanish-mexico
SmartMesh SDK: Smart Mesh SDK es un paquete de Python que simplifica la
 integración de una red SmartMesh IP o SmartMesh WirelessHART en su aplicación.
 Implementa la interfaz de programación de aplicaciones (API) del dispositivo
 al que está conectado.
 Se incluye un conjunto de aplicaciones de muestra en SmartMesh SDK, lo
 que permite al programador comprender rápidamente la API y usarla como
 parte de un sistema más grande.
 45
\end_layout

\begin_layout Section
Evaluación del desempeño de tecnologías de comunicación para IoT 
\end_layout

\begin_layout Standard
Evaluar el jitter de una conexión es importante, ya que es una variación
 en la demora entre los paquets enviados atraves de esta.
 En pocas palabras, un jitter alto, introduce inconsistencias, lo cual interfier
e con la calidad de la comunicación y la velocidad de la transferencia de
 datos.
 
\end_layout

\begin_layout Standard
La tasa de paquetes perdidos es otro punto al que se le debe dar importancia,
 ya que, como su nombre lo dice, es el porcentaje de paquetes perdidos que
 hubo durante una conexión entre dos nodos.
\end_layout

\begin_layout Standard
En este proyecto, un conjunto de herramientas fue desarrollado para evaluar
 jitter y tasa de paquetes perdidos dentro de una conexión entre dos dispositivo
s.
 Se creó una aplicación cliente-servidor para cada uno de los protocolos
 escogidos a evaluar.
 Todas la aplicaciones fueron creadas con el lenguaje C, bajo el ambiente
 de Linux.
 Para algunos protocolos solo se necesitaron algunas librerias especializadas,
 mientras que en otros, como en LoRa, fue necesaria una integración.
 
\end_layout

\begin_layout Standard
A continuación se muestra una descripción detallada de la aplicación que
 se creo para cada protocolo.
\end_layout

\begin_layout Subsection
Descripción, instalación y configuración.
\end_layout

\begin_layout Standard
El codigo utilizado en los experimentos se encuentra publicado en github:
 
\end_layout

\begin_layout Standard
https://github.com/floresBe/network_performance.
 
\end_layout

\begin_layout Subsubsection
Wi-fi (Paquetes UDP).
\end_layout

\begin_layout Paragraph
Descripción.
\end_layout

\begin_layout Standard
En la programación en C, un socket es un "enchufe" con el cual se crea una
 conexión con otro ordenador en la que se permite intercambiar datos.
 Para la evaluación de este protocolo, se creo una aplicación cliente-servidor,
 la cual, con la ayuda de la libreria <sys/socket.h> (parte de la biblioteca
 GNU de C) , se utilizaron sockets de tipo UDP para crear conexiones entre
 dos nodos.
 
\end_layout

\begin_layout Paragraph
Diseño de experimento
\end_layout

\begin_layout Subparagraph
El programa cliente se define con la siguiente estructura:
\end_layout

\begin_layout Enumerate
Verifica argumentos.
 
\end_layout

\begin_deeper
\begin_layout Standard
It should be used like this: ./Client_UDP server_name size_message number_package
s 
\end_layout

\end_deeper
\begin_layout Enumerate
Crea un socket con el protocolo para establecer la comunicación con el servidor.
\end_layout

\begin_deeper
\begin_layout Standard
(sockfd = socket(AF_INET, SOCK_DGRAM, 0))
\end_layout

\end_deeper
\begin_layout Enumerate
Crea un hilo para escuchar respuestas del servidor.
 
\end_layout

\begin_deeper
\begin_layout Standard
pthread_create(&thread_listen_server, NULL, listen_server, NULL);
\end_layout

\end_deeper
\begin_layout Enumerate
Envía al servidor el número de mensajes especificado en los argumentos.
 
\end_layout

\begin_deeper
\begin_layout Standard
send_data(s);
\end_layout

\end_deeper
\begin_layout Enumerate
Espera por un tiempo determinado 
\end_layout

\begin_deeper
\begin_layout Standard
while ( seconds_elapsed < timeout * 1000) 
\end_layout

\end_deeper
\begin_layout Enumerate
Calcula Jitter y Tasa de paquetes perdidos con los datos de los paquetes
 recibidos.
 
\end_layout

\begin_deeper
\begin_layout Standard
jitter = get_average(); 
\end_layout

\begin_layout Standard
rate = abs((((float) count_packages_received/(float)number_packages)* 100)
 - 100); 
\end_layout

\end_deeper
\begin_layout Enumerate
Crea archivos de texto para graficar con gnu.
 
\end_layout

\begin_deeper
\begin_layout Standard
create_gnu_files(rate,jitter);
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Subparagraph
El programa servidor se define con la siguiente estructura:
\end_layout

\begin_layout Enumerate
Crea un socket con el protocolo para poder establecer comunicación con algun
 cliente.
\end_layout

\begin_deeper
\begin_layout Standard
(sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 )
\end_layout

\end_deeper
\begin_layout Enumerate
Escucha hasta que un cliente le envia información atraves de la conexión.
 
\end_layout

\begin_deeper
\begin_layout Standard
recvfrom(sockfd, (char *)message_json, MAXLINE, MSG_WAITALL, ( struct sockaddr
 *) &cliaddr, &len); 
\end_layout

\end_deeper
\begin_layout Enumerate
Al recibir datos, agrega la hora actual en el mensaje y lo envía de vuelta
 al cliente.
 
\end_layout

\begin_deeper
\begin_layout Standard
sendto(sockfd, (char *)message_json, MAXLINE, 0, (const struct sockaddr
 *) &cliaddr, len);
\end_layout

\end_deeper
\begin_layout Paragraph
Instalación y configuración.
 
\end_layout

\begin_layout Standard
Para realizar el experimento, fue necesaria una red wifi utilizando un modem,
 y dos computadoras con un sistema operativo Linux instalado, en este caso
 se utilizo Ubuntu, ambas conectadas a la misma red.
\end_layout

\begin_layout Standard
Ejecutar el programa servidor en una de las computadoras inicia el experimento,
 despues de ejecutarse se queda a la espera de algun cliente que quiera
 enviarle información; a continuación se ejecuta el programa cliente en
 la otra computadora incluyendo utilizando los parametros: server_name size_mess
age number_packages, se crea la conexión y comienza el envío de mensajes.
 Al fnalizar, el cliente creara reportes con la información obtenida del
 jitter y tasa de paquetes perdidos durante la conexión.
\end_layout

\begin_layout Subsubsection
Bluetooth.
\end_layout

\begin_layout Paragraph
Descripción.
 
\end_layout

\begin_layout Standard
Para evaluar el protocolo de comunicación Bluetooth, se realizo una aplicación
 que se conforma por dos archivos .c, Server_Bluetooth.c (Servidor) y Client_Bluet
ooth.c (Cliente).
 Ambos utilizan la libreria BlueZ, una potente pila de comunicaciones Bluetooth
 con amplias APIs que permite al usuario aprovechar al máximo todos los
 recursos Bluetooth locales.
\end_layout

\begin_layout Standard
BlueZ proporciona soporte para las capas y protocolos centrales de Bluetooth.
 Es flexible, eficiente y utiliza una implementación modular.
 Se sabe que los módulos, bibliotecas y utilidades del kernel de BlueZ funcionan
 perfectamente en muchas arquitecturas compatibles con Linux.
 Esto también incluye plataformas de procesador único y multiprocesador,
 así como sistemas de hiperprocesamiento.
 El soporte para BlueZ se puede encontrar en muchas distribuciones de Linux
 y, en general, es compatible con cualquier sistema Linux del mercado.
 
\end_layout

\begin_layout Paragraph
Diseño de experimento.
\end_layout

\begin_layout Subparagraph
El programa cliente se define con la siguiente estructura:
\end_layout

\begin_layout Enumerate
Verifica argumentos.
 
\end_layout

\begin_deeper
\begin_layout Standard
It should be used like this: ./Client_Bluetooth device_name size_message
 number_packages 
\end_layout

\end_deeper
\begin_layout Enumerate
Crea un socket con el protocolo de Bluetooth para establecer la comunicación
 con el servidor.
\end_layout

\begin_deeper
\begin_layout Standard
socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM); 
\end_layout

\end_deeper
\begin_layout Enumerate
Inicializa una búsqueda para localizar al dispositivo bluetooth servidor.
 
\end_layout

\begin_deeper
\begin_layout Standard
Si lo encuentra, se conecta con el.
 connect(s, (struct sockaddr *)&address, sizeof(address)); 
\end_layout

\end_deeper
\begin_layout Enumerate
Crea un hilo para escuchar respuestas del servidor.
 
\end_layout

\begin_deeper
\begin_layout Standard
pthread_create(&thread_listen_server, NULL, listen_server, (void *)&listen_serve
r); 
\end_layout

\end_deeper
\begin_layout Enumerate
Envía al servidor el número de mensajes especificado en los argumentos.
 
\end_layout

\begin_deeper
\begin_layout Standard
send_data(s);
\end_layout

\end_deeper
\begin_layout Enumerate
Espera por un tiempo determinado.
\end_layout

\begin_deeper
\begin_layout Standard
while ( seconds_elapsed < timeout * 1000) 
\end_layout

\end_deeper
\begin_layout Enumerate
Calcular Jitter y Tasa de paquetes perdidos con los datos de los paquetes
 recibidos.
 
\end_layout

\begin_deeper
\begin_layout Standard
jitter = fabs(get_average()); 
\end_layout

\begin_layout Standard
rate = abs((((float) count_packages_received/(float)number_packages)* 100)
 - 100); 
\end_layout

\end_deeper
\begin_layout Enumerate
Crea archivos de texto para graficar con gnu.
 
\end_layout

\begin_deeper
\begin_layout Standard
create_gnu_files(rate,jitter); 
\end_layout

\end_deeper
\begin_layout Subparagraph
El programa servidor se define con la siguiente estructura:
\end_layout

\begin_layout Enumerate
Crea un socket con el protocolo de Bluetooth para establecer la comunicación
 con el cliente.
 
\end_layout

\begin_deeper
\begin_layout Standard
socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);
\end_layout

\end_deeper
\begin_layout Enumerate
Escucha hasta que un cliente pide establecer conexion.
 
\end_layout

\begin_deeper
\begin_layout Standard
listen(s, 1);
\end_layout

\end_deeper
\begin_layout Enumerate
Espera por datos del cliente.
\end_layout

\begin_deeper
\begin_layout Standard
ba2str( &rem_addr.rc_bdaddr, buf);
\end_layout

\end_deeper
\begin_layout Enumerate
Al recibir datos, agrega la hora actual en el mensaje y lo envía de vuelta
 al cliente.
 
\end_layout

\begin_deeper
\begin_layout Standard
void callback_function(char buf[MAXLINE], int client); 
\end_layout

\end_deeper
\begin_layout Paragraph
Instalación y configuración.
\end_layout

\begin_layout Standard
Para realizar el experimento, fueron necesarias dos computadoras con un
 sistema operativo Linux instalado, en este caso se utilizo Ubuntu, ambas
 equipadas con tarjetas bluetooth.
\end_layout

\begin_layout Standard
Ejecutar el programa servidor en una de las computadoras inicia el experimento,
 despues de ejecutarse se queda a la espera de algun cliente que quiera
 enviarle información; a continuación se ejecuta el programa cliente en
 la otra computadora incluyendo utilizando los parametros: device_name size_mess
age number_packages, se crea la conexión y comienza el envío de mensajes.
 Al fnalizar, el cliente creara reportes con la información obtenida del
 jitter y tasa de paquetes perdidos durante la conexión.
\end_layout

\begin_layout Subsubsection
ZigBee.
\end_layout

\begin_layout Paragraph
Descripción.
 
\end_layout

\begin_layout Standard
Para medir la calidad de un enlace de red de dispositivos ZigBee, se realizo
 una aplicación en lenguaje C y se conforma por dos archivos: Server_ZigBee.c
 (Servidor) y Client_ZigBee.c (Cliente).
 Cada programa se comunica con un dispositivo ZigBee (Digi XBee®) a través
 de un puerto serial/USB y con la ayuda de la libreria <xbee.h>.
 
\end_layout

\begin_layout Paragraph
Diseño de experimento.
\end_layout

\begin_layout Subparagraph
El programa cliente se define con la siguiente estructura:
\end_layout

\begin_layout Enumerate
Verifica argumentos.
 
\end_layout

\begin_deeper
\begin_layout Standard
xbee_address, USB_port_number, size_message, number_packages; 
\end_layout

\end_deeper
\begin_layout Enumerate
Configura la conexión con el dispositivo físico.
 
\end_layout

\begin_deeper
\begin_layout Standard
struct xbee * configure_xbee(struct xbee *xbee, xbee_err ret); 
\end_layout

\end_deeper
\begin_layout Enumerate
Configura la conexión con el dispositivo remoto (servidor).
 
\end_layout

\begin_deeper
\begin_layout Standard
struct xbee_con * connection_xbee(struct xbee *xbee, struct xbee_con *con,
 xbee_err ret); 
\end_layout

\end_deeper
\begin_layout Enumerate
Crea un hilo para escuchar respuestas del servidor.
 
\end_layout

\begin_deeper
\begin_layout Standard
pthread_create(&thread_listen_server, NULL, listen_server, (void *)&server_zigBe
e); 
\end_layout

\end_deeper
\begin_layout Enumerate
Envía al servidor el número de mensajes especificado en los argumentos.
 
\end_layout

\begin_deeper
\begin_layout Standard
void callback_function(struct xbee *xbee, struct xbee_con *con, struct xbee_pkt
 **pkt, void **data); 
\end_layout

\end_deeper
\begin_layout Enumerate
Espera por un tiempo determinado.
 
\end_layout

\begin_deeper
\begin_layout Standard
while ( seconds_elapsed < timeout * 1000) 
\end_layout

\end_deeper
\begin_layout Enumerate
Calcula Jitter y Tasa de paquetes perdidos con los datos de los paquetes
 recibidos.
 
\end_layout

\begin_deeper
\begin_layout Standard
jitter = fabs(get_average()); 
\end_layout

\begin_layout Standard
rate = abs((((float) count_packages_received/(float)number_packages)* 100)
 - 100); 
\end_layout

\end_deeper
\begin_layout Enumerate
Crea archivos de texto para graficar con gnu.
 
\end_layout

\begin_deeper
\begin_layout Standard
create_gnu_files(rate,jitter); 
\end_layout

\end_deeper
\begin_layout Subparagraph
El programa servidor se define con la siguiente estructura:
\end_layout

\begin_layout Enumerate
Configura la conexión con el dispositivo físico.
 
\end_layout

\begin_deeper
\begin_layout Standard
struct xbee * configure_xbee(struct xbee *xbee, xbee_err ret);
\end_layout

\end_deeper
\begin_layout Enumerate
Configura la conexión con el dispositivo remoto (cliente).
 
\end_layout

\begin_deeper
\begin_layout Standard
struct xbee_con * connection_xbee(struct xbee *xbee, struct xbee_con *con,
 xbee_err ret);
\end_layout

\end_deeper
\begin_layout Enumerate
Espera por datos del cliente indeterminadamente.
 
\end_layout

\begin_deeper
\begin_layout Standard
while (1) { receive_data(struct xbee xbee, struct xbee_con con, xbee_err
 ret); }
\end_layout

\end_deeper
\begin_layout Enumerate
Al recibir datos, agrega la hora actual en el mensaje y lo envía de vuelta
 al cliente.
 
\end_layout

\begin_deeper
\begin_layout Standard
void callback_function(struct xbee *xbee, struct xbee_con *con, struct xbee_pkt
 **pkt, void **data); 
\end_layout

\end_deeper
\begin_layout Paragraph
Instalación y configuración.
\end_layout

\begin_layout Standard
Para realizar el experimento, fueron necesarias dos computadoras con un
 sistema operativo Linux instalado, en este caso se utilizo Ubuntu.
 Los dispositivos se deben configurar segun la funcion a ejecutar y para
 esto se utiliza XCTU, una aplicación multiplataforma gratuita diseñada
 para que los desarrolladores puedan interactuar con los módulos RF de Digi
 a través de una interfaz gráfica.
 Incluye herramientas que facilitan la instalación, configuración y prueba
 de los módulos XBee® RF.
 
\end_layout

\begin_layout Subparagraph
Configuración del dispositivo cliente:
\end_layout

\begin_layout Itemize
ID, puede ser un número aleatorio pero deberá ser el mismo para ambos dispositiv
os, tanto «cliente» como «servidor».
\end_layout

\begin_layout Itemize
JV, activar la función de Verificación de canal, esto sirve para que el
 dispositivo verifique si existe un dispositivo «servidor» válido en ese
 canal.
\end_layout

\begin_layout Itemize
AP, asegurarnos de que el dispositivo está en modo API.
\end_layout

\begin_layout Itemize
P4, deberá de estar en modo de entrada para datos para que el dispositivo
 reciba las lecturas tomadas del sensor.
 
\end_layout

\begin_layout Subparagraph
Configuración del dispositivo servidor:
\end_layout

\begin_layout Itemize
ID, como ya se mencionó anteriormente, éste parámetro podrá ser un número
 aleatorio pero deberá ser el mismo para ambos dispositivos.
\end_layout

\begin_layout Itemize
JV, la función de Verificación de canal no es necesario que este activada
 en este dispositivo.
\end_layout

\begin_layout Itemize
CE, deberá estar activada la función de Coordinador.
\end_layout

\begin_layout Itemize
AP, el modo API deberá estar activado.
\end_layout

\begin_layout Itemize
P4, tampoco es necesario que esté activada la entrada de datos.
\end_layout

\begin_layout Itemize
SC, si el CH (operating channel) no es el mismo, SC(Scan Channels) debera
 permitir todos los canales con el valor FFFF.
 
\end_layout

\begin_layout Standard
Ejecutar el programa servidor en una de las computadoras inicia el experimento,
 despues de ejecutarse este se conecta con el dispositivo, se configura
 la conexión con el cliente y se queda en espera de algun mensaje de este.
 Al ejecutar el cliente, de igual manera se conecta con el dispositivo,
 despues configura la conexión con el servidor, una vez establecida la conexión
 comienza el envío de mensajes.
 Al fnalizar, el cliente creara reportes con la información obtenida del
 jitter y tasa de paquetes perdidos durante la conexión.
\end_layout

\begin_layout Subsection
Resultados.
\end_layout

\begin_layout Section
Conclusiones y trabajo futuro
\end_layout

\begin_layout Section
Referencias
\end_layout

\begin_layout Section
Anexos 
\end_layout

\end_body
\end_document
